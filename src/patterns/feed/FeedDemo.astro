---
import Feed, { type FeedArticle } from './Feed.astro';
import KeyboardHints from './KeyboardHints.astro';
import { getPatterns, type Pattern } from '@/lib/patterns';

const patterns = getPatterns();

const generateArticleFromPattern = (pattern: Pattern): FeedArticle => ({
  id: `article-${pattern.id}`,
  title: `${pattern.icon} ${pattern.name}`,
  description: pattern.description,
  content: `${pattern.description}\n\nView ${pattern.name} pattern: /patterns/${pattern.id}/astro/`,
});

const initialArticles: FeedArticle[] = patterns
  .slice(0, 3)
  .map((pattern) => generateArticleFromPattern(pattern));

// Pass patterns data to client-side script
const patternsJson = JSON.stringify(
  patterns.map((p) => ({
    id: p.id,
    name: p.name,
    icon: p.icon,
    description: p.description,
  }))
);
---

<apg-feed-infinite-demo data-patterns={patternsJson}>
  <div class="apg-feed-demo-wrapper">
    <KeyboardHints />
    <button type="button" class="apg-feed-demo-button" data-testid="before-feed" data-add-article>
      <svg aria-hidden="true" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
        <path
          d="M8 2a.75.75 0 0 1 .75.75v4.5h4.5a.75.75 0 0 1 0 1.5h-4.5v4.5a.75.75 0 0 1-1.5 0v-4.5h-4.5a.75.75 0 0 1 0-1.5h4.5v-4.5A.75.75 0 0 1 8 2z"
        ></path>
      </svg>
      Add Pattern
    </button>
    <div
      class="apg-feed-scroll-container"
      style="max-height: 400px; overflow: auto"
      data-scroll-container
    >
      <Feed
        articles={initialArticles}
        aria-label="APG Patterns feed with infinite scroll"
        setSize={-1}
        loadMoreRootMargin="100px"
        data-testid="feed-demo"
      />
      <div class="apg-feed-loading-indicator" aria-live="polite" data-loading-indicator hidden>
        Loading more articles...
      </div>
      <div class="apg-feed-end-message" data-end-message hidden>
        You've reached the end of the feed.
      </div>
    </div>
    <button type="button" data-testid="after-feed" class="apg-feed-demo-button" data-scroll-top>
      <svg aria-hidden="true" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
        <path
          d="M8 3.5a.75.75 0 0 1 .53.22l4 4a.75.75 0 1 1-1.06 1.06L8 5.31 4.53 8.78a.75.75 0 0 1-1.06-1.06l4-4A.75.75 0 0 1 8 3.5z"
        ></path>
        <path d="M8 7.5a.75.75 0 0 1 .75.75v4a.75.75 0 0 1-1.5 0v-4A.75.75 0 0 1 8 7.5z"></path>
      </svg>
      Back to top
    </button>
  </div>

  <template data-article-template>
    <article class="apg-feed-article" tabindex="-1" aria-posinset="" aria-setsize="-1">
      <h3 data-title></h3>
      <p data-description></p>
      <div class="apg-feed-article-content" data-content></div>
    </article>
  </template>
</apg-feed-infinite-demo>

<script>
  interface PatternData {
    id: string;
    name: string;
    icon: string;
    description: string;
  }

  class ApgFeedInfiniteDemo extends HTMLElement {
    private articleCount = 3;
    private loading = false;
    private hasMore = true;
    private patterns: PatternData[] = [];

    connectedCallback() {
      // Parse patterns data from attribute
      const patternsJson = this.dataset.patterns;
      if (patternsJson) {
        this.patterns = JSON.parse(patternsJson);
      }

      const apgFeed = this.querySelector('apg-feed');
      if (apgFeed) {
        apgFeed.addEventListener('feed:loadmore', () => this.loadMore());
      }

      const addArticleBtn = this.querySelector('[data-add-article]');
      if (addArticleBtn) {
        addArticleBtn.addEventListener('click', () => this.addSingleArticle());
      }

      const backToTopBtn = this.querySelector('[data-scroll-top]');
      if (backToTopBtn) {
        backToTopBtn.addEventListener('click', () => this.scrollToTop());
      }
    }

    addSingleArticle() {
      this.addArticles(1);
    }

    scrollToTop() {
      const scrollContainer = this.querySelector('[data-scroll-container]');
      scrollContainer?.scrollTo({ top: 0, behavior: 'smooth' });
    }

    loadMore() {
      if (this.loading || !this.hasMore) return;

      this.loading = true;
      const loadingIndicator = this.querySelector('[data-loading-indicator]');
      const feed = this.querySelector('[role="feed"]');

      if (loadingIndicator) {
        loadingIndicator.removeAttribute('hidden');
      }
      if (feed) {
        feed.setAttribute('aria-busy', 'true');
      }

      // Simulate API call
      setTimeout(() => {
        this.addArticles(2);
        this.loading = false;

        if (loadingIndicator) {
          loadingIndicator.setAttribute('hidden', '');
        }
        if (feed) {
          feed.setAttribute('aria-busy', 'false');
        }

        if (this.articleCount >= this.patterns.length) {
          this.hasMore = false;
          const endMessage = this.querySelector('[data-end-message]');
          if (endMessage) {
            endMessage.removeAttribute('hidden');
          }
        }
      }, 1000);
    }

    addArticles(count: number) {
      const feed = this.querySelector('[role="feed"]');
      const template = this.querySelector<HTMLTemplateElement>('[data-article-template]');
      const sentinel = feed?.querySelector('.apg-feed-sentinel');

      if (!feed || !template) return;

      for (let i = 0; i < count; i++) {
        if (this.articleCount >= this.patterns.length) break;

        this.articleCount++;
        const pattern = this.patterns[this.articleCount - 1];
        const clone = template.content.cloneNode(true) as DocumentFragment;
        const article = clone.querySelector('article');

        if (article && pattern) {
          const titleId = `infinite-article-${pattern.id}-title`;
          const descId = `infinite-article-${pattern.id}-desc`;

          article.setAttribute('aria-labelledby', titleId);
          article.setAttribute('aria-describedby', descId);
          article.setAttribute('aria-posinset', String(this.articleCount));

          const title = article.querySelector('[data-title]');
          const desc = article.querySelector('[data-description]');
          const content = article.querySelector('[data-content]');

          if (title) {
            title.id = titleId;
            title.textContent = `${pattern.icon} ${pattern.name}`;
          }
          if (desc) {
            desc.id = descId;
            desc.textContent = pattern.description;
          }
          if (content) {
            content.textContent = `${pattern.description}\n\nView ${pattern.name} pattern: /patterns/${pattern.id}/astro/`;
          }

          // Insert before sentinel if it exists, otherwise append
          if (sentinel) {
            feed.insertBefore(article, sentinel);
          } else {
            feed.appendChild(article);
          }
        }
      }

      // Update aria-posinset on all articles
      const articles = feed.querySelectorAll('[role="article"]');
      articles.forEach((article, index) => {
        article.setAttribute('aria-posinset', String(index + 1));
      });
    }
  }

  customElements.define('apg-feed-infinite-demo', ApgFeedInfiniteDemo);
</script>

<style>
  /* Styles are in src/styles/patterns/feed.css */
</style>
