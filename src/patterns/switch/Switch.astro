---
/**
 * APG Switch Pattern - Astro Implementation
 *
 * A control that allows users to toggle between two states: on and off.
 * Uses Web Components for client-side interactivity.
 *
 * @see https://www.w3.org/WAI/ARIA/apg/patterns/switch/
 */

export interface Props {
  /** Initial checked state */
  initialChecked?: boolean;
  /** Whether the switch is disabled */
  disabled?: boolean;
  /** Additional CSS class */
  class?: string;
}

const { initialChecked = false, disabled = false, class: className = '' } = Astro.props;
---

<apg-switch class={className}>
  <button
    type="button"
    role="switch"
    class="apg-switch"
    aria-checked={initialChecked}
    aria-disabled={disabled || undefined}
    disabled={disabled}
  >
    <span class="apg-switch-track">
      <span class="apg-switch-icon" aria-hidden="true">
        <svg viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M10.28 2.28a.75.75 0 00-1.06-1.06L4.5 5.94 2.78 4.22a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.06 0l5.25-5.25z"
            fill="currentColor"></path>
        </svg>
      </span>
      <span class="apg-switch-thumb"></span>
    </span>
    {
      Astro.slots.has('default') && (
        <span class="apg-switch-label">
          <slot />
        </span>
      )
    }
  </button>
</apg-switch>

<script>
  class ApgSwitch extends HTMLElement {
    private button: HTMLButtonElement | null = null;
    private rafId: number | null = null;
    private pointerStartX: number | null = null;
    private hasSwiped = false;
    private static readonly SWIPE_THRESHOLD = 10;

    connectedCallback() {
      this.rafId = requestAnimationFrame(() => this.initialize());
    }

    private initialize() {
      this.rafId = null;
      this.button = this.querySelector('button[role="switch"]');
      if (!this.button) {
        console.warn('apg-switch: button element not found');
        return;
      }

      this.button.addEventListener('click', this.handleClick);
      this.button.addEventListener('keydown', this.handleKeyDown);
      this.button.addEventListener('pointerdown', this.handlePointerDown);
      this.button.addEventListener('pointermove', this.handlePointerMove);
      this.button.addEventListener('pointerup', this.handlePointerUp);
    }

    disconnectedCallback() {
      if (this.rafId !== null) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
      this.button?.removeEventListener('click', this.handleClick);
      this.button?.removeEventListener('keydown', this.handleKeyDown);
      this.button?.removeEventListener('pointerdown', this.handlePointerDown);
      this.button?.removeEventListener('pointermove', this.handlePointerMove);
      this.button?.removeEventListener('pointerup', this.handlePointerUp);
      this.button = null;
    }

    private setCheckedState(newChecked: boolean) {
      if (!this.button) return;

      const currentChecked = this.button.getAttribute('aria-checked') === 'true';
      if (newChecked !== currentChecked) {
        this.button.setAttribute('aria-checked', String(newChecked));
        this.dispatchEvent(
          new CustomEvent('change', {
            detail: { checked: newChecked },
            bubbles: true,
          })
        );
      }
    }

    private toggle() {
      if (!this.button || this.button.disabled) return;

      const currentChecked = this.button.getAttribute('aria-checked') === 'true';
      this.setCheckedState(!currentChecked);
    }

    private handleClick = () => {
      if (this.hasSwiped) return;
      this.toggle();
    };

    private handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === ' ' || event.key === 'Enter') {
        event.preventDefault();
        this.toggle();
      }
    };

    private handlePointerDown = (event: PointerEvent) => {
      if (!this.button || this.button.disabled) return;
      this.pointerStartX = event.clientX;
      this.hasSwiped = false;
      const target = event.target as HTMLElement;
      target.setPointerCapture?.(event.pointerId);
    };

    private handlePointerMove = (event: PointerEvent) => {
      if (!this.button || this.button.disabled || this.pointerStartX === null) return;
      const deltaX = event.clientX - this.pointerStartX;
      if (Math.abs(deltaX) >= ApgSwitch.SWIPE_THRESHOLD) {
        this.hasSwiped = true;
        const newChecked = deltaX > 0;
        this.setCheckedState(newChecked);
        this.pointerStartX = null;
      }
    };

    private handlePointerUp = (event: PointerEvent) => {
      this.pointerStartX = null;
      const target = event.target as HTMLElement;
      target.releasePointerCapture?.(event.pointerId);
      // Reset hasSwiped after a microtask to allow click handler to check it
      queueMicrotask(() => {
        this.hasSwiped = false;
      });
    };
  }

  if (!customElements.get('apg-switch')) {
    customElements.define('apg-switch', ApgSwitch);
  }
</script>
